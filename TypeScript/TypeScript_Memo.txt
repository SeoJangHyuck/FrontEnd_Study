< 익명함수 >
- 함수명을 선언하지 않은 형태로 주로 람다 함수 형태로 표현되며 즉시 실행함수에 사용되거나 변수에 담아 사용


< Callback 함수>
- 고차함수의 인자 값을 전달받는 함수로써, 고차함수 실행이 끝난 후 후속 처리로 콜백함수가 실행 됨


< 비동기처리 >
- 요청과 응답이 순서없이 준비되는 데로 실행하는 처리과정


< Promise >
- ES6에서 콜백 헬을 피하기 위해 새롭게 추가된 함수로써 스코프가 깊어지지 않도록 나열식 패턴 방식으로 데이터를 처리
- ES6에서 새롭게 추가되어 구 브라우저와의 호환이 좋지않아 ES5로 구성된 구 브라우저에서는 추가로 프로미스만 사용 할 수 있도록 'tsc 해당파일.ts --lib ES2015.Promise,dom,es5' 옵션을 추가하여 컴파일 하는것이 좋음


< Promise 기본 구조 >
- new Promise((resolve, reject) => {

  });
- 프로미스 구조안에 (resolve, reject) => {..} 부분을 'excutor' 함수
- 생성자를 통해서 프로미스 객체를 만드는 순간을 'pending(대기)' 상태
- excutor 함수 인자 중 하나인 resolve 함수가 실행하면,'fulfilled(이행)' 상태
- excutor 함수 인자 중 하나인 reject 함수가 실행하면,'rejected(거부)' 상태
- '이행상태'가 된다면 resolve 함수를 통해 인자를 전달하여 then 메서드를 호출하며 결정된 값에 대해 후속처리를 담당
- '거부상태'일 경우 reject 함수를 통해 거부 사유의 인자를 전달하여 catch 메서드를 호출하여 전달된 이유를 표시하고 예외처리를 진행
- 마지막으로 추가적으로 작업을 진행해야 할 경우 .finally() 메서드를 호출하여 마무리를 할 수 있음, 이때 "lib": ["es2018.promise"] 으로 설정해야 사용가능

< Promise.resolve >
- 기본구조는 Promise.resolve(value); 형태로 value가 프로미스 객체인지 아닌지 알 수 없는 경우, 사용하면 연결된 then 메서드를 실행
- value가 프로미스 객체면, resolve된 then 메서드를 실행
- value가 프로미스 객체가 아니면, value를 인자로 보내면서 then 메서드를 실행


< Promise.reject >
- 기본구조는 Promise.reject(value); 형태로 catch로 연결된 rejected 상태로 변경


< Promise.all >
- 기본형태는 Promise.all([프로미스객체들]) 이며 작업완료 시점이 일정치 않은 비동기 처리의 내용을 호출순서 대로 정렬할때 용이
- 프로미스 객체를 여러개를 생성하여 배열로 만들어 이자로 넣고 Promise.all을 실행하면, 배열의 모든 프로미스 객체들이  fullfilled 되었을때, then의 함수가 실행되고 그 인자로 프로미스 객체들의 resolve 인자값을 배열로 반환


< Promise.race >
- 기본형태는 Promise.race([프로미스객체들]) 이며 가장 먼저 호출된 객채를 찾을 떄 용이
- 프로미스 객체를 여러개를 생성하여 배열로 만들어 이자로 넣고 Promise.race을 실행하면, 배열의 모든 프로미스 객체들 중에 가장 먼저 fullfilled 된 프로미스 객체를 then의 함수가 실행되고 그 인자로 프로미스 객체들의 resolve 인자값을 배열로 반환


< RxJS >
- RxJS는 반응형 프로그래밍 모델을 구현해 놓은 자바스크립트 기반 라이브러리로 데이터 흐름을 처리하는데 도움을 줌


< 옵저버블(observable) > 
- 연속된 데이터 스트림을 생성하는 객체
- 옵저버블에서 데이터가 만들어져서 옵저버인 구독자에게 전달
- 소켓이나, 배열, 화면에서 발생한 이벤트 등과 같은 데이터 소스를 한번에 하나씩, 연속으로 보내는 객체(스트리밍, streaming) 


< 옵저버블과 프로미스의 차이점 > 
- 옵저버블은 동작이 완료 되기 전에 이미 보낸 요청을 취소할 수 있음, 프로미스는 이미 보낸 요청에는 취소할 수 없음 
- 프로미스는 단 1개의 값을 처리 할 수 있지만, 옵저버블은 스트림으로 연결된 여러 값을 처리 할 수 있다는 것


< 옵저버 >
- 옵저버블이 생성한 연속된 데이터 스트림을 구독해서 사용하는 객체이며 옵저버블을 만들 때 주어진 매개 변수(observer)에는 옵저버블의 구독자에게 데이터를 보낼 수있는 세 가지 콜백함수가 있음
- next(): Number나 Array나 객체같은 여러 값을 subscribers에게 보냄
- error(): 자바스크립트 에러나 예외값을 보냄
- complete() : 어떤 값도 보내지 않음


< RxJS 시퀀스 >
- 옵저버블이 될 수 있는 데이터 타입
- 연속적이고 순차적이고 반복적으로 사용
- 선언적으로 사용 가능
- 요소에 접근 가능하도록 디자인 된 데이터


< RxJS 연산자 >
- of : 시퀀스 값들을 구독 함수로 전달
- create : 옵저버블을 생성한 뒤 구독 함수를 호출할 수 있음
- map : 시퀀스 값을 조건에 맞게 다른 값으로 변환
- from : 배열 시퀀스를 입력으로 받아 옵저버블을 생성
- concat : 여러 옵저버블을 순서대로 하나의 옵저버블로 생성
- every : 데이터 스트림의 값이 조건에 부합하는지 검사
- take : 데이터 스트림을 인수로 전달된 숫자번째까지 출력


< Async&Await >
- Async 함수 내부에선 Await를 사용하여 동기적으로 코드를 작성 가능
- Async의 최종 반환값은 항상 프로미스 객체


< await Promise.all >
- 두가지 이상의 비동기 함수를 동시에 기달릴 수 있게 사용되며 배열형식으로 반환


< 프로미스보다 Async&Await의 장점 >
- 기본적으로 then형태로 출력하기 때문에 then 메서드를 추가할 필요가 없기 때문에 코드가 간결하고 직관적임
- 프로미스가 서로 중첩되여 사용할 경우 보다 쉽게 코드 작성 가능
- 에러 핸들링을 try/catch를 통해서 동기와 비동기 에러 모두를 처리
- 에러 핸들리과 if 문 분기 또한 동기적으로 작성 가능
